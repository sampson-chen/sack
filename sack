#!/bin/bash
#
# @filename: sack
#
# @author: largely inspired from Sampson L. Chen (sampson-chen / slchen)
# @date: 2012--2014
#
# @description:
# s(hortcut)-ack - a faster way to use ack (ag or grep)!
#
# For more details:
# https://github.com/sampson-chen/sack
#
# @dependencies:
# - ack (http://betterthangrep.com/)
# - tee
# - awk
# - sed (GNU sed)
#
# @version:
# 1.0
#
# @license:
# - MIT as of this version.
#
# @usage:
# - for additional usage information, see README.md

# ==============================================================
# ==============================================================

# Script Functions

# Print help / usage information about sack
sack_print_help() {
    echo "usage sack: [options] pattern [path]"
    echo ""
    echo "Wrapper around ag, ack or grep"
    echo "  F [line_no] to open file at line [line_no]"
    echo ""
    echo "-ag   to use ag"
    echo "-ack  to use ack"
    echo "-grep to use grep"
    echo ""
}

# Prefixes a shortcut tag to relevant output lines.
display_shortcuts() {
    # Note that by default ack uses the --nogroup -H option by default when
    # output is piped or redirected, so we do get a file name on each line as $1
    # We could have restored the default look for ack with the --group option, but
    # it turns out that this is actually simpler to parse with --nogroup and then
    # reformat the output to match the --group formats.
    awk -v f_name="" -F':' '
    BEGIN {x=1};
    {
        if ($1 != f_name) {
            printf("\n%s\n", $1);
            f_name=$1;
        };
        printf("[%s] ", x);
        printf("%s", $2);
        for (i=3; i<=NF; i++) {
            printf(":%s", $i);
        }
        printf("\n");
        x++;
    };'
}

# Processes the output that goes into the shortcut file:
# Format: line_number:full_file_path
process_shorcut_paths() {
    # Using : as the delimiter here should be fine, because : is not used in file names
    awk -F':' '
    {
        print $2 " " $1;
    };'
}

# Remove the escaped characters that get piped from ack in order to preserve
# colored output to stdout
remove_escaped_chars() {
    # Need to do a check for the OS, because Linux uses a different sed
    # than OS X

    # Linux
    if [[ `uname` == "Linux" ]]; then
        sed -r "s/\[([0-9]{1,2}(;[0-9]{1,2}){0,2})?[m|K]//g"
    # OS X
    elif [[ `uname` == "Darwin" ]]; then
        sed -E "s/\[([0-9]{1,2}(;[0-9]{1,2}){0,2})?[m|K]//g"
    fi
    # @todo: implement support for other OSes at a later date
}


# =============================================
# ================ Main Script ================
# =============================================

# Deal with the options that only have to do with sack instead of ack
sack__option=$1
# By default, use ack:
sack__default_tool=ack
# Variable(s) to remove magic values from the code
sack__dev_null=/dev/null
# Color parameter is different for ack / ag than for grep:
if [ -z "$SACK_COLORS" ]; then
    sack__color_param=$SACK_COLORS
else
    sack__color_param='--color'
fi


# Sack shortcut file. '.~/.sack_shortcurt' if the variable SACK_SHORTCUT is not
# defined.
if [ -v $SACK_SHORTCUT ]; then
    sack__shortcut_file=$SACK_SHORTCUT
else
    sack__shortcut_file=~/.sack_shortcuts
fi

# Determine which search tool to use
if [[ "$sack__option" == "-ag" ]]; then
    sack__default_tool=ag
    shift
# Determine which search tool to use
elif [[ "$sack__option" == "-grep" ]]; then
    sack__default_tool='grep -r -I'
    sack__color_param='--color=always'
    shift
# Show help printout
elif [[ -z "$sack__option" || "$sack__option" == "-h" || "$sack__option" == "--help" || "$sack__option" == "--info" ]]; then
    sack_print_help
    echo ""
    exit 0
fi

# The actual wrapper around ack, ag or grep
$sack__default_tool $sack__color_param "$@" | tee >$sack__dev_null >(display_shortcuts) >(process_shorcut_paths | remove_escaped_chars > $sack__shortcut_file)

